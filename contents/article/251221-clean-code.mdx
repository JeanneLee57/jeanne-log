---
title: '계속 복잡해지는 기능, 언제 리팩터링 해야할까?'
summary: 단순한 기능으로 출발한 컴포넌트가 요구사항 추가로 스파게티 코드로 변해가는 과정을 겪으며, '덧대기'를 멈추고 아키텍처를 재설계해야 하는 순간에 대해 고민해봤습니다.
date: '2025-12-21'
tags:
  - retro
author: Jeanne
---

> 나쁜 코드가 쌓일수록 팀 생산성은 떨어진다. 우리(개발자)는 저자고, 독자가 읽기 쉬운 코드가 좋은 코드다.

로버트 C. 마틴, &lt;클린 코드&gt;에서 클린 코드의 필요성을 설명하며 나오는 문구들입니다.

처음 이 문구를 봤을 때는 그저 "좋은 말이네" 하고 넘겼습니다. 하지만 최근 사내 서비스의 사용자 기능 설정 페이지를 유지보수하면서 이 문장이 뼈저리게 다가왔습니다.

처음엔 정말 단순한 "기능 켜기/끄기" 스위치들의 모음이었습니다. 그런데 서비스가 고도화되면서 요구사항이 하나둘 추가되었고, 코드는 점차 엄청나게 복잡해졌습니다. 이 글은 그 코드를 다시 예쁘게 '빗질하기' 위해 고민했던 경험에 대한 회고입니다.

* 이 글에 첨부된 예시와 코드는 실제 사내 서비스의 코드를 단순화/변형한 것입니다.

---

## 1. 평화로운 시작: 그냥 배열에 넣고 돌리면 되지!

첫 기획은 아주 단순했기 때문에, 구현에 그리 어려울 것이 없었습니다

"사용자가 원하는 기능을 켜고 끌 수 있게 해주세요. 알림 설정, 다크 모드 같은 거요."

저는 복잡하게 생각하지 않았습니다. Keep It Simple, Stupid(KISS) 원칙대로 가장 단순하게 메뉴 정보를 담은 배열을 만들고, `map`을 돌려 렌더링했습니다.

```typescript
const MENU_ITEMS = [
  { id: 'notifications', label: '알림 수신', value: true },
  { id: 'darkMode', label: '다크 모드', value: false },
  // ...
];

return (
  <>
    {MENU_ITEMS.map(item => <MenuItem item={item} />)}
  </>
);
```

이때까지는 이런 단순하고 추상화 수준이 높지 않는 코드가 요구사항에 잘 맞는 코드였습니다.

미래의 복잡성을 미리 걱정해서 코드를 꼬아놓을 필요는 없으니까요. 하지만 이 평화는 오래가지 않았습니다.

---

## 2. 복잡성의 도입: 그런데 이제 이 기능은 다르게 동작한다면?

얼마 뒤, 다음과 같은 요구사항이 추가됐습니다.

" '분석' 기능을 끌 때는, 만약 사용자가 이미 저장해 둔 리포트가 있다면 경고 팝업을 띄워주세요. 사용자가 실수로 꺼서 데이터를 잃을 수 있으니까요."

이런 예외 사항이 추가된다면 어떻게 할까요? 아마 대부분은 if문을 하나 추가해 손쉽게 처리할 거라고 생각합니다.

저도 마찬가지로 생각했습니다. 토글 핸들러에 `if (id === 'analytics')` 조건을 추가하면 되겠죠. 그러나 이런 분기문이 찜찜하다는 사실만은 부정할 수 없었습니다.

### 코드가 풍기는 악취..

```typescript
const handleItemToggle = (item) => {
  // 찜찜한 부분 1: 함수가 '어떤 아이템인지'를 일일이 검사하기 시작함
  if (item.id === 'analytics') { 
    if (userHasReports) {
      openConfirmDialog("데이터가 숨겨집니다. 계속하시겠습니까?");
      return;
    }
  }
  
  // 찜찜한 부분 2: 만약 '회원 관리' 기능에도 비슷한 요청이 오면?
  // else if (item.id === 'memberManagement') { ... }
  // 코드가 점점 길어질 것 같은 불길한 예감이 들었습니다.
  
  setFieldValue(item.id, !currentValue);
};
```

마틴 파울러, &lt;리팩터링&gt;의 가르침을 생각해보면, 작은 if문만을 두고서는 조금 과장된 이야기일 수 있지만 'switch 문' 악취를 풍기고 있다고도 할 수 있습니다.

`switch`나 긴 `if-else` 체인은 "중복이 발생할 가능성이 높고, 새로운 조건이 추가될 때마다 코드를 수정해야 한다"는 신호입니다.

게다가 이건 단일 책임 원칙(SRP) 위반이기도 했습니다. 이 함수는 특정 기능을 켜고 끄는 기능만 해야 하는데 분석 기능의 데이터가 있는지 검사하는 일까지 떠안게 된 것입니다. 하나의 함수가 너무 많은 것을 알고 있었습니다.

---

## 3. 점점 더 가중되는 복잡성과 읽기 힘들어지는 코드

그럼에도, if문 하나로 코드가 어마어마하게 '더러워졌다'고만 할 수는 없을 것입니다. 불가피한 경우 간단한 if문으로 해결하는 것이 더 좋은 해결책일 때도 있다고 생각합니다.

하지만 더 많은 복잡성이 추가된다면 얘기는 달라집니다. 최근 추가된 '쇼핑몰' 기능의 요구사항을 구현하며 이를 체감할 수 있었습니다.

"쇼핑몰 기능을 끄면, 그 하위 기능인 '결제'와 '쿠폰' 기능도 같이 꺼져야 합니다."

단순한 경고창이 아니라, 메뉴 간의 강한 의존성이 생긴 것입니다.

### 1차 시도: 헬퍼 함수의 늪 (잘못된 추상화)
처음 작성된 코드는 너무 많은 `if-else`를 줄이기 위해 일반화된 헬퍼 함수들을 도입했습니다.

```typescript
// 헬퍼 함수로 추상화를 시도했으나, 오히려 코드가 복잡해졌습니다.
const handleToggleWithConfirm = ({
  willDeactivating, // 토글을 on->off로 변경하는지에 대한 boolean
  triggerType, // 토글이 어떤 메뉴 아이템에 의해 발생했는지 확인
  dependencyCheck, // confirm 다이얼로그를 띄우기 위해 확인이 필요한 추가 의존성 체크
  onToggle, // 토글 시에 실행할 로직
}) => {
  // ... 복잡한 제어 흐름 ...
  if (willDeactivating && dependencyCheck()) {
     // ... 또 다른 함수 호출
  }
};

const handleItemToggle = (item) => {
  const toggleItem = () => {
    if (willDeactivating) {
       // 쇼핑몰을 끄면 결제, 쿠폰도 끈다
       disableChildFeatures(['payment', 'coupon']); 
       setFieldValue(item.id, false);
       return;
    }
    // ...
  };
}
```

** 문제점 1: 함수 이름과 내용의 불일치 **
`handleToggleWithConfirm`이라는 이름만 보면 "확인창을 띄우는 함수" 같지만, 실제로는 확인창이 필요 없는 일반 토글이나 하위 기능을 끄는 로직까지 섞여 있었습니다. 이는 '놀람 최소화 원칙'을 위반합니다.

** 문제점 2: 인자 폭발 **
함수 하나가 너무 많은 설정값과 콜백을 받고 있었습니다. 각 인자가 내부에서 어떻게 얽히는지 파악하려면 함수 내부를 뜯어봐야만 했죠. 이는 나쁜 추상화의 사례라고 할 수 있습니다.

이런 상태가 되자, 저는 리팩터링을 더는 미룰 수 없다는 사실을 깨달았습니다. "기반 구조가 잘못되었을 때는 덧대지 말고 부숴야 한다."

---

## 4. 최종 해결: 로직의 제어권을 데이터에게 넘기기

저는 복잡하고 이름과 다른 기능을 하는 헬퍼 함수들을 삭제하고, 순수하게 데이터(config)가 로직을 주도하는 구조로 다시 짰습니다.

### 리팩터링의 핵심: 선언적(Declarative) 설정으로 전환

저는 복잡한 함수 호출의 사슬을 끊어내고, "이 메뉴는 어떤 규칙을 가지는가"만 정의하기로 했습니다.

#### 1. 행동을 정의하는 인터페이스
먼저 각 메뉴 아이템이 검증 로직과 실행 로직을 가질 수 있도록 인터페이스를 명확히 정의했습니다.

```typescript
export interface MenuItemType {
  id: string;
  confirmMessage?: string; // 확인 창에 띄울 메시지
  // Strategy: "나를 끌 때 검사가 필요한가요?"
  shouldConfirm?: (context: ToggleContext) => boolean;
  // Command: "확인 버튼 누르면 추가로 할 일이 있나요?" (부수 효과 정의)
  onConfirm?: (setFieldValue: Setter) => void;
}
```

#### 2. 로직을 데이터로 옮기기
그리고 복잡한 로직들을 컴포넌트 함수 밖으로 끄집어내어, 설정 객체 안에 선언적으로 정의했습니다. 이제 코드가 "무엇"을 검사하는지 명확히 말해줍니다.

```typescript
// '쇼핑몰' 메뉴의 설정 - 이곳만 보면 비즈니스 로직을 전부 파악할 수 있습니다.
{
  id: 'shop_feature',
  label: '쇼핑몰 기능',
  confirmMessage: '쇼핑몰 기능을 끄면 결제와 쿠폰 기능도 함께 꺼집니다. 계속하시겠습니까?',
  
  // 조건: 쇼핑몰을 끄려는데 + 하위 기능(결제, 쿠폰)이 켜져있으면 -> 알림창 노출
  shouldConfirm: ({ values }) => values['shop_feature'] && (values['payment'] || values['coupon']),
  
  // 행동: 사용자가 "그래도 끌래" 하면 -> 하위 기능들도 같이 끈다.
  onConfirm: (setFieldValue) => {
    setFieldValue('payment', false);
    setFieldValue('coupon', false);
  },
}
```

#### 3. 단순해진 컴포넌트
이제 컴포넌트의 핸들러 함수는 매우 명료하고 가벼워졌습니다. 그저 설정된 규칙을 따라갈 뿐입니다.

```typescript
const handleItemToggle = async (item: MenuItemType) => {
  // 1. 확인이 필요한가? (설정 객체에게 위임)
  if (item.shouldConfirm?.({ values })) {
    const confirmed = await requestConfirm(item.confirmMessage);
    if (!confirmed) return;
    
    // 2. 확인 후 할 일이 있는가? (설정 객체에게 위임)
    item.onConfirm?.(setFieldValue);
  }
  
  // 3. 값 변경
  setFieldValue(item.id, !currentValue);
};
```

---

## 5. 리팩터링의 의미: AI 시대에도 우리는 왜 코드를 다듬어야 하는가?

기술적인 리팩터링은 이렇게 일단은 마무리되었습니다. 하지만 이런 일련의 과정에 노력과 시간을 들이면서 저는 AI 시대에 리팩터링의 의미에 대해서도 깊이 고민하게 되었습니다.

요즘은 AI 에이전트가 코드를 짜주는 시대입니다. "이 기능 추가해줘"라고 말하면 순식간에 코드를 뱉어냅니다. 그렇다면 리팩터링이나 클린 코드는 이제 옛날이야기가 된 걸까요? '깨끗한' 코드든 '더러운' 코드든 결국 AI가 이해하고 고칠 수만 있다면 상관 없지 않을까요?

결론부터 말하자면, 리팩터링은 더 중요해졌고, 개발자에게 있어 더 이루기 쉬운 일이 되었다고 생각합니다.

### AI는 수단일 뿐, '설계자'는 나다

AI는 뛰어난 도구지만, 전체적인 시스템의 구조와 방향성을 결정하는 것은 결국 개발자입니다. AI는 제 명령을 효율적으로 수행하는 역할을 할 뿐입니다.

도구가 제 역할을 하려면 입력값이 명확해야 합니다. 개발자가 시스템의 구조를 머릿속에 명확히 그리고 있어야 하고, 그 구조가 코드에 그대로 반영되어 있어야만 AI에게 정확한 지시를 내릴 수 있습니다.

만약 코드가 엉망진창이라면 개발자부터가 시스템을 온전히 파악할 수 없습니다. "쇼핑몰 기능을 고치려면 어디를 봐야 하지?" 하고 헤매는 순간, AI에게도 모호한 지시를 내릴 수밖에 없습니다.

오히려 AI 시대에 들어서면서 클린 코드는 이전보다 훨씬 쉬워졌습니다. 과거에는 복잡하게 꼬인 코드를 분석하고 대안을 찾는 데만 해도 엄청난 에너지가 필요했지만, 이제는 AI의 도움을 받아 '더러운' 코드의 의도와 흐름을 훨씬 더 쉽게 파악할 수 있기 때문입니다.

AI는 코드의 악취를 빠르게 찾아내고, 이를 해결하기 위한 리팩터링 방안을 빠르게 제안해줍니다. 개발자는 이제 코드 분석에 드는 수고를 AI에게 나누어 주고, 제시된 여러 대안 중 최적의 해법을 선택하고 검증하는 역할에 더 집중할 수 있게 되었습니다. 이것이 제가 AI 시대에도 여전히 클린 코드와 리팩터링이 중요하다고 생각하는 이유입니다.

---

## 결론

이번 리팩터링을 통해 코드는 분명 더 좋아졌습니다.

### 개선된 점
1.  관심사의 분리: 컴포넌트는 그리기만 하고, 복잡한 정책은 설정 객체가 담당합니다. 덕분에 코드 가독성이 획기적으로 좋아졌습니다.
2.  확장성 확보: 이제 다른 기능에 복잡한 confirm 조건이 붙어도 쉽게 기능 추가를 할 수 있습니다. OCP(개방-폐쇄 원칙)를 몸소 체험했습니다.
3.  심리적 안정감: 얽혀있는 코드를 풀어 모든 부분을 명쾌하게 이해하고 나니, 배포할 때 혹시 다른 기능이 망가지지 않을까? 하는 불안감이 사라졌습니다.

물론 지금의 구조가 만능은 아닐 것입니다. 로직이 컴포넌트에서 빠져나갔을 뿐, 결국 거대한 설정 객체가 모든 비즈니스 로직을 안고 있기 때문입니다.

또 다른 요구사항으로 지금의 구조가 더는 최적의 해가 아닌 순간이 오면 그때 다시 리팩터링을 고민해 봐야 할 것입니다.
