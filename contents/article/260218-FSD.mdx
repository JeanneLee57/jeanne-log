---
title: "폴더 구조 지옥 탈출기: FSD 아키텍처로 응집성 되찾기"
date: "2026-02-16"
tags: ["FSD", "Feature-Sliced Design", "architecture", "refactoring", "frontend"]
description: "“파일의 위치만 봐도 그 파일의 역할을 알 수 있다면 얼마나 좋을까?” 이 질문에서 시작된 FSD 아키텍처 마이그레이션 여정을 공유합니다."
---

# 폴더 구조 지옥 탈출기: FSD 아키텍처로 응집성 되찾기

"이 Card 컴포넌트 어디 있더라?"

프로젝트가 커질수록 이 질문을 스스로에게 던지는 횟수가 늘어났습니다. `components/card` 폴더를 열면 200개 이상의 파일이 병렬적으로 존재했고, 그 중 무엇이 재사용 가능한 UI이고 무엇이 비즈니스 로직을 담은 도메인 컴포넌트인지 이름만으로는 알 수 없었습니다.

"파일의 위치만 봐도 그 파일의 역할을 알 수 있다면 얼마나 좋을까?"

이 질문에서 시작된 FSD(Feature-Sliced Design) 아키텍처 마이그레이션 여정을 공유합니다.

---

## components 폴더가 쓰레기장이 되어가는 과정

입사 초기에는 폴더 구조가 크게 문제되지 않았습니다. 프로젝트 규모가 작았고, `components` 폴더 안에 몇십 개 파일이 있어도 찾는 데 큰 어려움이 없었습니다.

```
src/
  components/
    card/
      EmissionCard.tsx
      ActivityCard.tsx
      InventoryCard.tsx
      ...
  hooks/
  utils/
  pages/
```

전형적인 **역할별 폴더 구조(Role-based Structure)**였습니다. 하지만 프로젝트가 커져 갈수록 '이게 맞나?' 하는 생각이 들기 시작했습니다.
아주 크고 도메인 로직이 집약돼 있는 카드 컴포넌트(?)부터 아주 작고 거의 재사용성이 없는 컴포넌트까지 성격도 역할도 제각기 다른 컴포넌트들이 전부 카드라는 이름을 가지고 혼재하고 있으니 구조를 바꿔야겠다는 생각이 점차 커져갔습니다.

### 결정적 계기: PCF/CBAM 페이지 작업

문제는 PCF(Product Carbon Footprint)와 CBAM(Carbon Border Adjustment Mechanism) 관련 페이지 작업을 시작하면서 시작됐습니다. 기존에 사용하지 않던 포맷의 디자인이 대량으로 추가되면서, `components/card` 폴더에 또다시 다양한 "카드" 컴포넌트들이 쏟아져 들어왔습니다.

`components/card/` 폴더에는 이제  **200개 이상의 파일**이 존재하게 되었고, 하나의 도메인 폴더에 수십개의 파일이 들어가 있는 일까지 생겨났습니다.


### 구체적인 페인포인트

**1. 파일 탐색의 어려움**

200개가 넘는 Card 파일 중에서 내가 찾는 컴포넌트가 무엇을 하는지 알려면 **파일을 열어서 코드를 읽어야** 했습니다. 이름만으로는 알 수 없었습니다.

더 큰 문제는 **의존 관계 파악**이었습니다. 200개 파일 중 일부는 독립적이고, 일부는 서로를 참조합니다. 그 관계를 확인하려면 매번 `Cmd + 클릭`으로 파일을 따라가는 수밖에 없었습니다.

"부모의 부모의 부모의..." 무한 컨트롤 클릭.

실제 `components/card/` 폴더 구조를 보면 문제가 더 명확해집니다.

```
components/card/
  ByProcessBarEChart.tsx
  ByProcessSection.tsx
  ByProcessSkeleton.tsx
  ByProductDetailSection/          # 이 폴더 하나만 31개 파일
    ByProductDetailSection.tsx
    ByProductDetailSkeleton.tsx
    CbamFlowInfoTooltip.tsx
    CbamHierarchyList.tsx
    CbamPrecursorListTableCard.tsx
    CbamReportCard.tsx
    CbamTotalIntensityAndEmissionBarChartCard.tsx
    PcfHierarchyList.tsx
    PcfReportCard.tsx
    PcfReportSkeleton.tsx
    ... (총 31개 파일: 컴포넌트, 유틸, 테스트 혼재)
  ByScopeDonutChart.tsx
  ByScopeSection.tsx
  EmissionTrendBadge.tsx
  EmptyStateCard.tsx
  ProductListItem.tsx
  TotalByProductCard.tsx
  ... (총 200개 이상)
```

하나의 하위 폴더(`ByProductDetailSection/`)만 봐도 컴포넌트, 유틸 함수, 상수, 테스트가 뒤섞여 있습니다. 이게 도메인별로 분리된 것도 아니고, 단지 "PCF/CBAM 상세 보기"라는 기능 하나를 위한 파일들이 한 곳에 모여있을 뿐입니다.

**2. 응집성 저하**

같은 비즈니스 로직을 다루는 파일들이 흩어져 있었습니다.

- PCF 관련 Card 컴포넌트 → `components/card/`
- PCF 관련 Hook → `hooks/`
- PCF 관련 API 함수 → `utils/api/`

PCF 기능을 수정하려면 최소 3개 폴더를 넘나들어야 했습니다. 관계성은 네이밍으로 추측될 뿐이고, 개발자가 네이밍 센스가 조금만 떨어져도 "이거 도대체 어디에 쓰는 파일이야?" 알 수 없게 되는 일이 잦았습니다.

**3. 네이밍의 한계**

`components/card/`에는 "카드"라는 이름을 달고 있지만, 실제로는 완전히 다른 책임을 가진 컴포넌트들이 혼재했습니다. 단순 UI 카드와 도메인 로직 카드를 구분하려면 접두사나 접미사를 붙일 수밖에 없었지만, 그것도 한계가 있었습니다.

이 시점에서 생각했습니다. "더는 안 된다. 바꿔야 한다."

---

## FSD(Feature-Sliced Design)와의 만남

해결책을 찾던 중, 알고 지내던 개발자의 블로그에서 FSD 아키텍처를 접했습니다. 처음 봤을 때는 "오, 이런 것도 있구나" 정도로 넘겼습니다.

하지만 폴더 구조 문제가 심각해지면서 다시 찾아보게 되었고, FSD 아키텍쳐를 소개한 테오님의 블로그 글([FSD 관점으로 바라보는 코드 경계 찾기](https://velog.io/@teo/fsd))에서 다음 구절을 읽고 "바로 이거다!" 싶었습니다.

> "기존의 역할별 폴더 구조는 중규모 프로젝트까지는 잘 동작하지만, 프로젝트가 커지면서 한계를 드러냅니다. 코드베이스가 커지게 되면 `/components`, `/hooks`, `/utils` 폴더 등에 수많은 파일이 쌓이고, 이를 다시 분류하려고 하면 프로젝트마다 제각각의 구조를 가지게 됩니다.
>
> 이러한 현상이 벌어지는 이유는 **'역할'이라는 단일 관점의 관심사만으로 코드를 구성**했기 때문입니다. 실제로 프로젝트에는 역할뿐만이 아니라 도메인, 기능, 데이터의 흐름 등 다양한 관심사가 존재하며, 이를 세밀하게 분리할 필요가 있습니다."

우리 프로젝트의 문제를 정확히 짚은 글이라는 생각이 들었고, 당장 실천에 옮겨보자는 마음을 먹었습니다.


## 3. AI agent만 믿었다가 발등 찍힌 이야기

### 첫 시도: AI야, "해 줘"

FSD 공식 문서와 예제를 AI에게 던지며 생각했습니다.

> "이 정도면 마법처럼 잘 고쳐주겠지?"

일단 FSD의 기본 레이어 구조를 만들었습니다.

```
src/
  app/          # 앱 초기화, 라우팅
  pages/        # 페이지 구성
  widgets/      # 페이지의 독립적인 블록
  features/     # 사용자 시나리오, 기능
  entities/     # 비즈니스 엔티티
  shared/       # 재사용 가능한 UI, 유틸
```

그리고 AI에게 물었습니다.

> "기존 파일들을 FSD 구조로 분류해줘."

그때 알았어야 했습니다. FSD 공식 문서에서 괜히 '점진적 마이그레이션을 위한 가이드를 제공하는 게 아니라는 것을..

수분 뒤 ai가 완성해 놓은 구조를 열어보니 완전히 엉망이었습니다.

- `shared/` 폴더에 온갖 **비즈니스 로직**이 들어가 있었습니다.
- `widgets/` 폴더는 사실상 `components/card/` 200개 파일을 그대로 옮겨놓은 것뿐이었습니다. **index 파일도 없고, 도메인별 슬라이스도 없이** 병렬로 존재했습니다.

AI는 "파일을 옮기는" 작업은 할 수 있었지만, **"어디에 어떤 책임을 둘지"** 판단은 하지 못했습니다.

### 현실적인 접근: 10개의 티켓으로 나눠서

이건 한 번에 끝낼 수 있는 작업이 아니라는 것을 깨닫고 결국 작업을 **10개 정도의 티켓으로 나눠** 점진적으로 진행했습니다.

1. `shared` 레이어 정리 (공통 UI만 남기기)
2. `entities` 레이어 구축 (비즈니스 엔티티 분리)
3. `features` 레이어 구축 (기능별 분리)
4. `widgets` 레이어 구축 (페이지 블록 분리)
5. 순환 참조 해결
6. index 파일 생성 (캡슐화)
7. 의존성 방향 검증
8. ... (나머지 작업들)

---

## 4. 고난: 가장 힘들었던 3가지

### 1) 의존성 역전 바로잡기

처음에 "일단 파일 옮기고 보자" 식으로 시작했더니, 나중에 **의존성 방향이 꼬여** 큰 고생을 했습니다.

FSD의 핵심 규칙은 **"상위 레이어는 하위 레이어에만 의존할 수 있다"**입니다.

```
app → pages → widgets → features → entities → shared
```

그런데 `shared`에 있는 컴포넌트가 `entities`를 참조하거나, `features`가 `widgets`를 참조하는 경우가 발생했습니다. 이를 하나하나 풀어내는 과정이 가장 힘들었습니다.

### 2) index 파일 생성의 귀찮음

FSD는 각 슬라이스마다 **public API를 정의하는 index 파일**을 권장합니다. 캡슐화를 위한 것인데, 처음에는 "왜 굳이?" 싶었습니다.

```typescript
// entities/emission/index.ts
export { EmissionCard } from './ui/EmissionCard';
export { useEmissionData } from './model/useEmissionData';
// 내부 구현은 노출하지 않음
```

하지만 작업하면서 index 파일이 캡슐화의 일등공신이라는 것을 깨달았습니다. 다른 도메인이나 레이어에서 필요한 것만 외부로 노출하고 그렇지 않은 것은 캡슐화함으로써 의존성 관계를 분명히 하고 번들 사이즈도 효율적으로 관리할 수 있는 고마운 존재였습니다.

### 3) 분류 기준 정하기: widget? feature? entities?

"이 컴포넌트는 widget인가, feature인가, entities인가?"

팀에서 가장 많이 논의한 질문입니다. FSD 공식 문서에도 명확한 답은 없고, 프로젝트마다 유연하게 정의해야 합니다.

우리 팀은 다음과 같은 기준을 세웠습니다.

- **widgets**: 하나의 페이지에서 핵심 로직을 담당하는 **가장 큰 컴포넌트**
- **features**: 사용자 인터랙션을 다루는 **기능 단위** (예: "배출 활동 등록", "배출계수 수정")
- **entities**: 비즈니스 엔티티 (예: Emission, Activity, Inventory)

하지만 여전히 애매한 케이스가 있습니다. 많은 이들이 입을 모아 말하듯 계속되는 토론과 기준 다듬기가 필요한 부분입니다.

---

## 5. 결과: 응집성이란 무엇인가를 시각화하다

### 레이어만 봐도 책임이 보인다

이제 파일을 볼 때 **어느 레이어에 있는지만 봐도** 그 파일이 무엇을 알고 있고, 무엇에 의존하는지 파악할 수 있습니다.

```
src/
  entities/
    emission/          # 배출 엔티티만 관심사
      ui/EmissionCard.tsx
      model/useEmissionData.ts
      api/emissionApi.ts
  features/
    emission-register/ # 배출 등록 기능
      ui/RegisterForm.tsx
      model/useRegister.ts
```

`entities/emission`에 있는 컴포넌트는 "나는 Emission 도메인만 알아!"라고 말합니다.  
`features/emission-register`에 있는 컴포넌트는 "나는 배출 등록 기능을 담당해!"라고 말합니다.

**파일의 위치가 곧 역할의 선언**이 되었습니다.

### 응집성의 시각화: 슬라이스 폴더를 열었을 때의 쾌감

FSD를 도입하고 가장 짜릿했던 순간은, 도메인별 슬라이스 폴더를 열었을 때였습니다.

```
entities/emission/
  ui/
    EmissionCard.tsx
    EmissionTable.tsx
  model/
    useEmissionData.ts
    emissionStore.ts
  api/
    emissionApi.ts
  index.ts
```

**같은 도메인 지식을 공유하는 파일들**이 예쁘게 하나의 슬라이스 안에 정리되어 있는 것을 보는 순간, "응집성이란 무엇인가?"에 대한 대답을 시각화한 기분이었습니다.

## 6. 교훈: FSD는 완성이 아니라 시작이다

FSD를 도입하면서 깨달은 것이 있습니다.

**"폴더 구조를 정하면 끝!"이 아니라는 것.**

FSD는 **지속적인 관리와 토론이 필요한 구조**입니다.

- "이 컴포넌트는 어느 레이어에 두는 게 맞을까?"
- "이 기능은 feature로 뺄까, widget에 둘까?"
- "이 정도는 shared로 내려도 될까?"

정답은 없습니다. 프로젝트의 특성에 맞게 유연하게 적용하는 것이 중요합니다.

### 우리 프로젝트만의 유연한 적용 사례

공식 FSD 가이드를 그대로 따르기보다, 우리 프로젝트에 맞게 일부 규칙을 조정했습니다.

**1) widgets 내 fetch 허용**

FSD 원칙상 widgets는 데이터를 직접 가져오지 않고, page에서 데이터를 받아야 합니다. 하지만 우리 프로젝트에서는 **widgets가 독립적으로 fetch하는 것을 허용**했습니다.

이유: widgets가 fetch할 수 없다면 page가 너무 많은 책임을 지게 되고, 코드가 오히려 복잡해졌습니다.

**2) entities 하위 그룹핑 허용**

모든 API 엔드포인트마다 전부 폴더를 만들면 너무 폴더가 많아지고 복잡해져, 오히려 작업 속도가 저하될 수 있었습니다. 그래서 **entities 하위에서 관련 API를 그룹핑**하는 것을 허용했습니다.

```
entities/
  emission/
    api/
      emissionApi.ts        # 여러 emission 관련 API 그룹핑
      emissionFactorApi.ts
```

---

## 마치며

FSD 도입은 단순히 폴더를 재배치한 것이 아니라, **코드베이스에 대한 사고방식을 바꾼 경험**이었습니다.

- "이 코드는 무엇을 알아야 하는가?"
- "이 컴포넌트는 무엇에 의존해야 하는가?"
- "어떻게 하면 응집성을 높이고 결합도를 낮출 수 있는가?"

이런 질문들을 끊임없이 던지며 코드를 정리했고, 그 결과 **파일의 위치만 봐도 역할을 알 수 있는** 구조를 만들 수 있었습니다.

물론 아직 완벽하지 않습니다. 계속해서 기준을 다듬고, 팀과 토론하며, 더 나은 구조를 찾아가야 합니다.

하지만 적어도 이제는 `components/card/` 폴더를 열고 "도대체 이게 뭐야..." 한숨 쉬는 일은 없어졌습니다.

